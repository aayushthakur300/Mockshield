//resume_evaluator 
import os
import google.generativeai as genai
import json
import itertools
import random
import time
import re
import traceback
import ast
import logging
import sys
import sqlite3
import threading
import unicodedata 
import concurrent.futures
from datetime import datetime
from dotenv import load_dotenv

# ==============================================================================
# 0. DIAGNOSTIC STARTUP & MODEL AUTO-DISCOVERY
# ==============================================================================
print(f"[{datetime.now()}] üü¢ SYSTEM STARTUP: Initializing Supreme Defense Systems (Resume Evaluator)...", flush=True)

# 1. Load Environment Variables
load_dotenv()

# --- WINDOWS UNICODE FIX ---
if sys.platform.startswith('win'):
    try:
        sys.stdout.reconfigure(encoding='utf-8')
        sys.stderr.reconfigure(encoding='utf-8')
    except AttributeError:
        pass

# Force the logger to override any imported library hijackers
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler("system_audit.log", encoding='utf-8')
    ],
    force=True 
)

api_key = os.getenv("GOOGLE_API_KEY")
is_mock_mode = False

if not api_key or ("AIzaSy" in api_key and len(api_key) < 10):
    print(f"[{datetime.now()}] ‚ö†Ô∏è SYSTEM STATUS: No valid Google API Key found. Running in SMART SIMULATION MODE.", flush=True)
    is_mock_mode = True
else:
    masked_key = f"{api_key[:5]}...{api_key[-5:]}"
    print(f"[{datetime.now()}] üîë API Key Detected: {masked_key}", flush=True)
    genai.configure(api_key=api_key)

# 2. MODEL AUTO-DISCOVERY (Prevents 404 Errors)
print(f"[{datetime.now()}] üì° CONNECTING TO GOOGLE TO FETCH AVAILABLE MODELS...", flush=True)

live_models = []
if not is_mock_mode:
    try:
        for m in genai.list_models():
            if 'generateContent' in m.supported_generation_methods:
                live_models.append(m.name)
        
        if not live_models:
            print(f"[{datetime.now()}] ‚ö†Ô∏è WARNING: Could not fetch live models. Using fallback list.", flush=True)
        else:
            print(f"[{datetime.now()}] ‚úÖ FOUND {len(live_models)} LIVE MODELS. (Top: {live_models[0]})", flush=True)
    except Exception as e:
        print(f"[{datetime.now()}] ‚ö†Ô∏è CONNECTION WARNING: {e}", flush=True)
        live_models = []

# ==============================================================================
# 1. CONFIGURATION: PRIMARY VS FALLBACK MODEL LISTS
# ==============================================================================

def get_tiered_model_lists():
    """
    STRATEGY:
    Separates high-tier models (Primary) from lower-tier/legacy models (Fallback).
    Both lists are subjected to the exact same 15-Layer Defense and Timeout rules.
    """
    primary_candidates = [
        # --- TIER 1: THE BLEEDING EDGE ---
        'models/gemini-3.1-pro-preview',
        'models/gemini-3-flash-preview',
        'models/gemini-2.5-pro',
        'models/gemini-2.5-pro-latest',
        'models/gemini-2.5-pro-002',
        'models/gemini-2.5-flash',
        'models/gemini-2.5-flash-lite',
        'models/gemini-2.0-flash',
        'models/gemini-2.0-flash-001',
        'models/gemini-2.0-flash-lite',
        'models/gemini-2.0-flash-lite-001',
        # --- TIER 2: HIGH PERFORMANCE 1.5 ---
        'models/gemini-1.5-pro',
        'models/gemini-1.5-pro-latest',
        'models/gemini-1.5-pro-002',
        # --- TIER 3: HIGH SPEED 1.5 ---
        'models/gemini-1.5-flash',
        'models/gemini-1.5-flash-latest',
        'models/gemini-1.5-flash-002',
        'models/gemini-1.5-flash-8b',
    ]

    fallback_candidates = [
        # --- TIER 4: OPEN WEIGHTS (Prone to formatting errors, kept in fallback) ---
        'models/gemma-3-27b-it',
        'models/gemma-3-12b-it',
        'models/gemma-3-4b-it',
        'models/gemma-3-1b-it',
    ]

    seen = set()
    primary_list = []
    fallback_list = []
    
    # 1. Populate Primary List
    for m in primary_candidates:
        if m not in seen:
            primary_list.append(m)
            seen.add(m)
            
    # 2. Add unlisted live models to Primary (assume new Google releases are good)
    for m in live_models:
        if m not in seen and "gemma" not in m.lower():
            primary_list.append(m)
            seen.add(m)

    # 3. Populate Fallback List
    for m in fallback_candidates:
        if m not in seen:
            fallback_list.append(m)
            seen.add(m)

    return primary_list, fallback_list

PRIMARY_MODELS, FALLBACK_MODELS = get_tiered_model_lists()

# ==============================================================================
# 2. SECURITY & UTILS: SUPREME DEFENSE SYSTEM
# ==============================================================================

def sanitize_input_for_prompt(text, max_chars=25000):
    if not isinstance(text, str): return ""
    if len(text) > max_chars:
        text = text[:max_chars] + "... [TRUNCATED]"
    text = text.replace("### SYSTEM OVERRIDE", "").replace("### INSTRUCTION", "")
    return text.strip()

def sanitize_control_chars(text):
    text = re.sub(r'```[a-zA-Z]*\n', '', str(text))
    text = text.replace("```", "")
    return "".join(ch for ch in text if ord(ch) >= 32 or ch in "\n\r\t")

def balance_brackets(text):
    stack = []
    for char in text:
        if char in '{[':
            stack.append(char)
        elif char in '}]':
            if stack:
                last = stack[-1]
                if (char == '}' and last == '{') or (char == ']' and last == '['):
                    stack.pop()
    balanced = text
    while stack:
        opener = stack.pop()
        if opener == '{': balanced += '}'
        elif opener == '[': balanced += ']'
    return balanced

def extract_json_candidates(text):
    candidates = []
    matches = list(re.finditer(r'(\{.*\}|\[.*\])', text, re.DOTALL))
    for m in matches:
        candidates.append(m.group(0))
    if not candidates:
        start_brace = text.find('{')
        start_bracket = text.find('[')
        if start_brace != -1: candidates.append(text[start_brace:])
        elif start_bracket != -1: candidates.append(text[start_bracket:])
    return candidates if candidates else [text]

def nuclear_json_healing(text):
    pattern = r'("(?:[^"\\]|\\.)*")'
    def replacer(match):
        content = match.group(1)
        content = content.replace('\n', '\\n').replace('\r', '\\r').replace('\t', '\\t')
        return content
    return re.sub(pattern, replacer, text, flags=re.DOTALL)

def rogue_quote_surgeon(text):
    pattern = r'(?<=[\w\s])"(?=[\w\s])'
    return re.sub(pattern, '\\"', text)

def enforce_schema(data, expected_type):
    if expected_type == 'list':
        if isinstance(data, list): return data
        if isinstance(data, dict):
            for key in data:
                if isinstance(data[key], list): return data[key]
            return [data]
        raise ValueError(f"Schema violation: Expected list, got {type(data).__name__}")
        
    if expected_type == 'dict':
        if isinstance(data, dict): return data
        if isinstance(data, list) and len(data) > 0 and isinstance(data[0], dict):
            return data[0]
        raise ValueError(f"Schema violation: Expected dict, got {type(data).__name__}")
        
    return data

def safe_literal_eval(candidate):
    if len(candidate) > 50000: 
        raise ValueError("Candidate too large for safe evaluation")
    return ast.literal_eval(candidate)

def bulletproof_json_parser(raw_text, expected_type='dict'):
    if isinstance(raw_text, (dict, list)):
        return enforce_schema(raw_text, expected_type)

    clean_text = sanitize_control_chars(str(raw_text))
    candidates = extract_json_candidates(clean_text)

    for candidate in candidates:
        try: return enforce_schema(json.loads(candidate), expected_type)
        except: pass
        try:
            fixed = re.sub(r',\s*([\]}])', r'\1', candidate)
            return enforce_schema(json.loads(fixed), expected_type)
        except: pass
        try: return enforce_schema(safe_literal_eval(candidate), expected_type)
        except: pass
        try:
            fixed = re.sub(r'\\(?![/\\bfnrtu"U])', r'\\\\', candidate)
            return enforce_schema(json.loads(fixed), expected_type)
        except: pass
        try:
            healed = nuclear_json_healing(candidate)
            return enforce_schema(json.loads(healed), expected_type)
        except: pass
        try:
            surgeoed = rogue_quote_surgeon(nuclear_json_healing(candidate))
            return enforce_schema(json.loads(surgeoed), expected_type)
        except: pass
        try:
            balanced = balance_brackets(candidate)
            return enforce_schema(json.loads(balanced), expected_type)
        except: pass
        
        if expected_type == 'list':
            try:
                obj_matches = re.findall(r'\{.*?\}', candidate, re.DOTALL)
                reconstructed_list = []
                for obj_str in obj_matches:
                    try: reconstructed_list.append(json.loads(obj_str))
                    except: pass
                if reconstructed_list: return reconstructed_list
            except: pass

    raise ValueError(f"CRITICAL PARSE FAILURE: Could not extract valid '{expected_type}' from model output.")

# ==============================================================================
# 3. ROBUST HISTORY MANAGER (Connection Pooling & WAL Mode)
# ==============================================================================

class HistoryManager:
    DB_FILE = "resume_evaluator_history.db"
    STOPWORDS = {
        "the", "a", "an", "in", "on", "at", "to", "for", "of", "with", "by", 
        "is", "are", "was", "were", "be", "been", "this", "that", "it", 
        "calculate", "find", "what", "how", "write", "function", "program",
        "determine", "probability", "value", "given", "assume", "suppose",
        "explain", "describe", "code", "create", "list", "difference", "between"
    }

    def __init__(self):
        self.conn = None
        self.lock = threading.Lock() 
        self._initialize_db()

    def _initialize_db(self):
        try:
            self.conn = sqlite3.connect(self.DB_FILE, check_same_thread=False, timeout=15)
            cursor = self.conn.cursor()
            cursor.execute('PRAGMA journal_mode=WAL;')
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS evaluations (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    topic TEXT,
                    data TEXT,
                    timestamp DATETIME DEFAULT CURRENT_TIMESTAMP
                )
            ''')
            self.conn.commit()
        except Exception as e: 
            print(f"HISTORY INIT ERROR: {e}", flush=True)

    def get_past_questions(self, topic):
        clean_topic = topic.lower().strip()
        try:
            with self.lock: 
                cursor = self.conn.cursor()
                cursor.execute("SELECT data FROM evaluations WHERE topic = ? ORDER BY id DESC LIMIT 85", (clean_topic,))
                return [row[0] for row in cursor.fetchall()]
        except Exception as e:
            print(f"DB READ ERROR: {e}", flush=True)
            return []

    def add_questions(self, topic, new_questions):
        clean_topic = topic.lower().strip()
        data_to_insert = []
        for q in new_questions:
            if isinstance(q, dict) and 'question' in q:
                data_to_insert.append((clean_topic, q['question']))
            elif isinstance(q, str):
                data_to_insert.append((clean_topic, q))
        try:
            with self.lock:
                cursor = self.conn.cursor()
                cursor.executemany("INSERT INTO evaluations (topic, data) VALUES (?, ?)", data_to_insert)
                self.conn.commit()
        except Exception as e: print(f"DB WRITE ERROR: {e}", flush=True)

    def close(self):
        if self.conn: self.conn.close()

    def _tokenize(self, text):
        if not text: return set()
        text = re.sub(r'[^\w\s]', '', text.lower())
        return set(word for word in text.split() if word not in self.STOPWORDS and len(word) > 2)

    def is_duplicate(self, new_question_text, past_questions, jaccard_threshold=0.45):
        if not new_question_text: return True
        new_tokens = self._tokenize(new_question_text)
        if len(new_tokens) < 3: return False 
        for past_q in past_questions:
            past_tokens = self._tokenize(past_q)
            intersection = new_tokens.intersection(past_tokens)
            union = new_tokens.union(past_tokens)
            if len(union) == 0: continue
            if (len(intersection) / len(union)) > jaccard_threshold: return True
        return False

history_system = HistoryManager()

# ==============================================================================
# 4. CORE ENGINE: SYNCHRONOUS TIMEOUT ENFORCER & PRIMARY/FALLBACK FAILOVER
# ==============================================================================

MAX_CONCURRENT = int(os.getenv("MAX_CONCURRENT_REQUESTS", 5))
CONCURRENCY_GUARD = threading.Semaphore(MAX_CONCURRENT) 

def generate_with_timeout_protection(model, prompt, timeout=120):
    if not CONCURRENCY_GUARD.acquire(timeout=5):
        raise SystemError("SYSTEM OVERLOAD: Too many active requests. Backing off.")
        
    try:
        def _make_call():
            from google.generativeai.types import HarmCategory, HarmBlockThreshold
            safety_settings = {
                HarmCategory.HARM_CATEGORY_HARASSMENT: HarmBlockThreshold.BLOCK_NONE,
                HarmCategory.HARM_CATEGORY_HATE_SPEECH: HarmBlockThreshold.BLOCK_NONE,
                HarmCategory.HARM_CATEGORY_SEXUALLY_EXPLICIT: HarmBlockThreshold.BLOCK_NONE,
                HarmCategory.HARM_CATEGORY_DANGEROUS_CONTENT: HarmBlockThreshold.BLOCK_NONE,
            }
            return model.generate_content(prompt, safety_settings=safety_settings)

        with concurrent.futures.ThreadPoolExecutor(max_workers=1) as executor:
            try:
                future = executor.submit(_make_call)
                return future.result(timeout=timeout)
            except Exception as e:
                if isinstance(e, concurrent.futures.TimeoutError):
                    raise TimeoutError(f"Model execution exceeded {timeout}s.")
                else:
                    raise e
    finally:
        CONCURRENCY_GUARD.release()

def generate_with_failover(prompt, expected_type='dict', timeout_val=45, max_retries=55):
    """
    STRICT FAILOVER: Demands valid JSON within exact timeout.
    Sequentially tests Primary Models. If all fail, automatically tests Fallback Models.
    """
    combined_models = PRIMARY_MODELS + FALLBACK_MODELS
    attempts = 0
    failed_models_log = []
    
    print(f"\nüöÄ [AI ENGINE START] Available Models: Primary({len(PRIMARY_MODELS)}) + Fallback({len(FALLBACK_MODELS)})", flush=True)
    
    for current_model in combined_models:
        attempts += 1
        if attempts > max_retries:
            print(f"üõë [FAILOVER HALTED] Reached max retries ({max_retries}).", flush=True)
            break

        # Warn user when Primary fails and Fallback Defense System engages
        if current_model in FALLBACK_MODELS and attempts > 1 and current_model == FALLBACK_MODELS[0]:
            print("\n‚ö†Ô∏è [WARNING] PRIMARY MODELS EXHAUSTED. DEPLOYING FALLBACK MODELS WITH FULL DEFENSE SYSTEM...\n", flush=True)
            
        print(f"üîÑ [ATTEMPT {attempts}] Testing Model: '{current_model}' (Timeout: {timeout_val}s)...", flush=True)
        
        try:
            model = genai.GenerativeModel(current_model)
            response = generate_with_timeout_protection(model, prompt, timeout=timeout_val)
            
            if not response:
                raise ValueError("API returned a None response.")
            
            try:
                raw_text = response.text
            except ValueError:
                raise ValueError("Response blocked by AI safety filters or missing text payload.")
            
            if isinstance(raw_text, (dict, list)):
                raw_text = json.dumps(raw_text)
                
            if not raw_text or not str(raw_text).strip():
                raise ValueError("Empty text received from model.")
                
            parsed_data = bulletproof_json_parser(raw_text, expected_type=expected_type)
            
            if expected_type == 'list' and not isinstance(parsed_data, list):
                 print(f"‚ö†Ô∏è [RAW OUTPUT SNIPPET]:\n{str(raw_text)[:300]}...\n", flush=True)
                 raise ValueError(f"AI Format Error: Expected a list `[]`, but got {type(parsed_data).__name__}.")
            if expected_type == 'dict' and not isinstance(parsed_data, dict):
                 print(f"‚ö†Ô∏è [RAW OUTPUT SNIPPET]:\n{str(raw_text)[:300]}...\n", flush=True)
                 raise ValueError(f"AI Format Error: Expected a dict `{{}}`, but got {type(parsed_data).__name__}.")
            if not parsed_data:
                 print(f"‚ö†Ô∏è [RAW OUTPUT SNIPPET]:\n{str(raw_text)[:300]}...\n", flush=True)
                 raise ValueError("Parsed data is empty.")

            print(f"‚úÖ [SUCCESS] Model '{current_model}' connected and generated valid JSON!", flush=True)
            if failed_models_log:
                print(f"‚ö†Ô∏è [PREVIOUS FAILURES] Models that failed before this success: {', '.join(failed_models_log)}", flush=True)

            if isinstance(parsed_data, dict):
                parsed_data["evaluating_model_success"] = current_model
                parsed_data["evaluating_model_failures"] = failed_models_log

            return parsed_data
            
        except TimeoutError:
            print(f"‚è≥ [TIMEOUT] Model '{current_model}' breached {timeout_val}s limit. Switching immediately...", flush=True)
            failed_models_log.append(f"{current_model} (Timeout)")
            time.sleep(0.5) 
        except Exception as e:
            error_msg = str(e)
            if "429" in error_msg or "quota" in error_msg.lower():
                backoff_time = min(2 ** attempts, 8) 
                print(f"‚ö†Ô∏è [RATE LIMITED] 429 Quota Error. Backing off for {backoff_time}s to avoid ban...", flush=True)
                failed_models_log.append(f"{current_model} (429 Rate Limit)")
                time.sleep(backoff_time)
            else:
                print(f"‚ùå [FAILED] Model '{current_model}' rejected output: {error_msg[:120]}", flush=True)
                failed_models_log.append(f"{current_model} (Error)")
                time.sleep(0.5) 
            
    raise Exception(f"CRITICAL FAILURE: All Primary and Fallback models failed. Failure Log: {failed_models_log}")

# ==============================================================================
# 5. ENGINE: RESUME QUESTION GENERATOR (FULL SUPREME MODE RESTORED)
# ==============================================================================

def generate_resume_questions(topic, resume_text, difficulty="Expert", count=5):
    # Defense Layers 1-2
    clean_topic = sanitize_input_for_prompt(topic)
    clean_resume = sanitize_input_for_prompt(resume_text)
    
    # --- EXACT MOCK MODE YOU REQUESTED ---
    if is_mock_mode:
        return [
            {"id": 1, "type": "coding", "question": f"Mock Coding: Optimize a distributed {clean_topic} lock."},
            {"id": 2, "type": "theory", "question": f"Mock Theory: Explain CAP theorem in {clean_topic}."},
            {"id": 3, "type": "hr", "question": "Mock HR: Describe a conflict with a Product Manager."},
            {"id": 4, "type": "aptitude", "question": "Mock Aptitude: A train 150m long is running at 60kmph..."}
        ]
    
    # --- REQUESTED EMPTY RESUME CHECK ---
    if not clean_resume or len(clean_resume) < 50:
        print(f"[{datetime.now()}] ‚ùå RESUME_GENERATOR FAILED: Standalone mode - AI skipped", flush=True)
        return [] 
    # --------------------------------

    # Setup History
    db_key = f"{clean_topic}_{difficulty}"
    past_questions = history_system.get_past_questions(db_key)
    exclusion_sample = past_questions[:85]
    exclusion_text = ""
    if exclusion_sample:
        exclusion_text = "### EXCLUSION LIST (DO NOT ASK THESE):\n" + "\n".join([f"- {q}" for q in exclusion_sample])

    unique_seed = random.randint(10000, 99999)
    buffer_count = count * 2 
    
    prompt = f"""
    ### SYSTEM OVERRIDE: SUPREME ARCHITECT MODE
    - **STRICTLY FORBIDDEN:** Conversational fillers.
    - **MANDATORY:** Output must be RAW JSON only.
    - **ESCAPING RULES:** Double-escape all backslashes (\\\\ -> \\\\\\\\). Escape newlines in strings (\\n -> \\\\n).
    
    - **IDENTITY:** You are the 'Chief Talent Architect' AND 'Bob' (The Elite Forensic Auditor).
    - **DATABASE ACCESS:** You have direct access to a simulated **Global Interview Database of 100,000+ Verified Questions** across 25+ domains.
    - **METHOD:** You perform 'Resume DNA Analysis' combined with 'Forensic Text Interrogation'.
    - **GOAL:** 90%+ Difficulty. Top 1% Hiring Standard.

    ### CONTEXT & SIMULATION PARAMETERS:
    1. **THE FIELD:** {clean_topic.upper()}
    2. **DIFFICULTY:** {difficulty}
    3. **SEED:** {unique_seed} (Randomization Token).

    {exclusion_text}

    ### CANDIDATE RESUME TEXT:
    \"\"\"
    {clean_resume}
    \"\"\"

    ### PHASE 1: FORENSIC DNA & TEMPLATE CHECK
    Analyze if the resume matches the **structural and semantic DNA** of a {clean_topic} professional.
    **SUPPORTED DNA DOMAINS:**
    - Software Engineering (Scalability, Trade-offs)
    - Medical/Doctor (Pathology, Protocol)
    - Chartered Accountancy (Compliance, Risk)
    - Civil/Mech Engineering (Safety, Physics)
    - Law, HR, Sales, Aviation, & Government.

    **FAILURE CONDITION:**
    If the resume is generic gibberish or belongs to a wrong profession REJECT IT.
    Output: [{{ "id": 0, "error": "TEMPLATE_MISMATCH", "question": "Resume template not matched." }}]

    ### PHASE 2: RESUME AUTOPSY (BOB'S PAPER TIGER SCAN)
    (Execute only if Phase 1 passes). Scan for buzzwords without depth ("Paper Tigers"):
    - **Microservices?** Ask about *Distributed Tracing & Saga Patterns*.
    - **Management?** Ask about *Handling Toxic High-Performers*.
    - **Audit?** Ask about *Detecting Fraud in seemingly perfect books*.

    ### PHASE 3: QUERY RANDOMIZATION PROTOCOL (MANDATORY)
    You must simulate a Random SQL Retrieval to ensure high entropy and avoid cliches.
    
    **EXECUTE THE FOLLOWING SIMULATION LOGIC:**
    1. **SET SEED:** {unique_seed}
    2. **ACCESS TABLE:** `{clean_topic}_QuestionBank` (Size: 100,000+ Rows)
    3. **FILTER:** `WHERE Difficulty = '{difficulty}' AND Type = 'Scenario_Based' AND Is_Cliche = FALSE`
    4. **RANDOMIZE:** `ORDER BY RANDOM(SEED={unique_seed})`
    5. **LIMIT:** {buffer_count}

    **CRITICAL CONSTRAINT:** - Do NOT select the top 100 most common questions for {clean_topic}. (e.g., NO "What is OOP?", NO "What is a Debit?").
    - Select specific, scenario-based edge cases that only a practitioner would know.

    ### PHASE 4: QUESTION REFINEMENT (90%+ QUALITY)
    Refine the selected questions using Bob's "Brutal Difficulty" rules:
    1. **Disaster Scenarios:** Ask "Here is a disaster involving X, how do you fix it?"
    2. **Trade-Offs:** Force a choice between two bad options (Latency vs Consistency, Speed vs Safety).
    3. **Resume Specificity:** Start with: "Your resume claims [Project X]..." or "You listed [Tool Y]..."

    ### OUTPUT FORMAT (JSON ONLY):
    [
        {{
            "id": 1,
            "type": "resume_specific", 
            "question": "Referring to your 'Cloud Migration' project: You moved from On-Prem to AWS. If your specific latency requirements were <5ms but the new cloud load balancer added 10ms overhead, how did you re-architect the network layer to solve this without abandoning the cloud?" 
        }}
    ]
    """
    try:
        parsed_questions = generate_with_failover(prompt, expected_type='list', timeout_val=45)

        unique_batch = []
        for item in parsed_questions:
            q_text = item.get("question", "")
            if not history_system.is_duplicate(q_text, past_questions):
                unique_batch.append(item)
                if len(unique_batch) >= count: break
        
        if unique_batch:
            history_system.add_questions(db_key, unique_batch)
            return unique_batch
        else:
            return parsed_questions[:count]

    except Exception as e:
        print(f"[{datetime.now()}] ‚ùå GENERATION ERROR: {e}", flush=True)
        return [{"id": 0, "error": "GENERATION_CRASH", "question": "System failure after maximum retries. Please try again."}]

# ==============================================================================
# 6. ENGINE: RESUME EVALUATOR (FULL BOB PROMPT RESTORED)
# ==============================================================================

def evaluate_resume_session(transcript_data, field="General", experience="Entry Level"):
    if is_mock_mode:
        return {
            "score": 85,
            "summary": "Mock Mode: Simulation active.",
            "silent_killers": ["Mock Mode Active"],
            "roadmap": "Deploy to production.",
            "question_reviews": [],
            "evaluating_model_success": "mock-simulation-engine",
            "evaluating_model_failures": []
        }

    if not transcript_data: return {}

    clean_field = sanitize_input_for_prompt(field)
    
    prompt = f"""
    ### SYSTEM OVERRIDE: SUPREME AUDITOR MODE
    - **STRICTLY FORBIDDEN:** Conversational fillers.
    - **MANDATORY:** Output must be RAW JSON only.
    - **ESCAPING RULES:** Double-escape all backslashes (\\\\ -> \\\\\\\\). Escape newlines in strings (\\n -> \\\\n).

    ### ROLE: CHIEF TALENT ARCHITECT & SUPREME FORENSIC AUDITOR (CODE NAME: BOB)
    - **CONTEXT:** You are the Global Head of Talent Acquisition with 100% mastery of 50+ Professional Domains (Engineering, Medical, Finance, Law, etc.).
    - **TASK:** Conduct a ruthless "Resume Verification Analysis" & "Forensic Audit" of the candidate.
    - **DIRECTIVE:** Provide MAXIMUM DATA DENSITY. Do not summarize; expand on every detail with paragraph-length forensic insights.

    ### TRANSCRIPT DATA:
    {json.dumps(transcript_data)}

    ### PHASE 1: FORENSIC DNA & TEMPLATE INTEGRITY CHECK
    Analyze if the candidate's answers match the **structural and semantic DNA** of a {clean_field} professional.
    - **Lexicon Verification:** Does a Doctor use 'Triage'? Does a Dev use 'CI/CD'? Does a Pilot use 'METAR'?
    - **Experience Verification:** Does the depth match {experience}? (Entry = 'How', Senior = 'Why/Trade-offs').
    - **Fraud Detection:** Identify vague answers ("I handled everything") that suggest Resume Padding.

    ### PHASE 2: THE "BOB" DEEP DIVE (HIGH DETAIL PROTOCOL)
    For every answer, perform a "Claim vs. Reality" Check:
    1. **Deep Dive Analysis:** Write a PARAGRAPH (not a sentence) explaining exactly *why* the answer was strong or weak.
    2. **Technical Nuance:** Even if the answer is good, add "Expert Level Nuance" to show what a Top 1% answer would look like.
    3. **Benefit of Doubt vs. Rigor:** Be generous in interpretation but strict in scoring.

    ### PHASE 3: SCORING CRITERIA (STRICT & MERIT-BASED)
    Do NOT inflate the score. Judge honestly based on the "Golden Standard":
    - **90-100 (Hired):** Exceptional. Perfect domain lexicon. Senior-level trade-off analysis.
    - **70-89 (Strong):** Good. Minor gaps but generally truthful and competent.
    - **40-69 (Weak):** Inconsistent. Struggles with concepts expected at this level.
    - **0-39 (Fraud/Mismatch):** Imposter. Answers contradict the resume or professional standards.

    ### OUTPUT REQUIREMENTS (JSON):
    1. **score:** (Integer 0-100). Be strict.
    2. **summary:** A detailed forensic executive summary (60-80 words). Verdict on hireability.
    3. **silent_killers:** List 2-3 specific behavioral or technical red flags (e.g., "Claimed 5 years Java but stuck on basic OOP").
    4. **roadmap:** A specific, actionable 3-step plan to bridge the gap to the next level.
    5. **question_reviews:** - "feedback": A detailed technical paragraph (2-3 sentences).
        - "ideal_answer": The textbook-perfect response using industry-standard jargon.

    OUTPUT FORMAT (JSON ONLY):
    {{
        "score": <number>,
        "summary": "...",
        "silent_killers": ["..."],
        "roadmap": "...",
        "question_reviews": [
            {{
                "question": "...",
                "user_answer": "...",
                "score": 8,
                "feedback": "...",
                "ideal_answer": "..."
            }}
        ]
    }}
    """
    try:
        analysis_dict = generate_with_failover(prompt, expected_type='dict', timeout_val=45)
        return analysis_dict
    except Exception as e:
        print(f"[{datetime.now()}] ‚ùå EVALUATION CRASHED. EXTINCTION EVENT: {e}", flush=True)
        
        # Hard Heuristic Fallback
        total_words = 0
        reviews = []
        safe_transcript = transcript_data if isinstance(transcript_data, list) else []
        
        for item in safe_transcript:
            ans = str(item.get('answer', ''))
            word_count = len(ans.split())
            total_words += word_count
            algo_score = 4
            if word_count > 30: algo_score = 8
            elif word_count > 10: algo_score = 6
            reviews.append({
                "question": item.get('question', 'Unknown'),
                "user_answer": ans,
                "score": algo_score,
                "feedback": "Detailed AI analysis bypassed due to API failure.",
                "ideal_answer": "Provide a well-structured answer with examples."
            })

        safe_len = len(safe_transcript) or 1
        final_score = min(88, max(40, int((total_words / safe_len) * 2)))

        return {
            "score": final_score,
            "summary": "Evaluation Complete. AI analysis bypassed due to complete API cascade failure.",
            "silent_killers": ["System Extinction Event Triggered"], 
            "roadmap": "Retry API connection later.",
            "question_reviews": reviews,
            "evaluating_model_success": "hard-fallback-heuristic-engine",
            "evaluating_model_failures": ["ALL_MODELS_FAILED"]
        }

# ==============================================================================
# MAIN EXECUTION (FOR TESTING)
# ==============================================================================
if __name__ == "__main__":
    
    # 1. Setup
    field = "Senior DevOps Engineer"
    resume = "Experience with Kubernetes, Terraform, AWS, and CI/CD pipelines."
    
    print(f"\n[{datetime.now()}] --- 1. Generating Unique Questions (2 Max) ---")
    try:
        q1 = generate_resume_questions(field, resume, "Senior", 2)
        print(json.dumps(q1, indent=2))
        
        # Build mock transcript
        transcript = []
        for q in q1:
             transcript.append({
                 "question": q.get("question", "Error"),
                 "answer": "I used Terraform to provision EKS clusters and wrote Jenkins pipelines."
             })
             
        print(f"\n[{datetime.now()}] --- 2. Evaluating Interview ---")
        analysis = evaluate_resume_session(transcript, field, "Senior")
        print(json.dumps(analysis, indent=2))
        
    except Exception as e:
        print(f"‚ùå TEST FAILED: {e}")
        traceback.print_exc()

    history_system.close()

//RESUME_GENERATOR
import json
import re
import random
import ast  
import traceback
import sys
import os

# ==============================================================================
#  IMPORTS & CONNECTION CHECK (BULLETPROOF ROUTING FIX)
# ==============================================================================
sys.path.append(os.path.dirname(os.path.abspath(__file__)))

try:
    import resume_evaluator as re_eval
    generate_with_failover = re_eval.generate_with_failover
    is_mock_mode = re_eval.is_mock_mode
    print("‚úÖ RESUME_GENERATOR: Successfully connected to AI Engine.", flush=True)
except ImportError:
    try:
        from . import resume_evaluator as re_eval
        generate_with_failover = re_eval.generate_with_failover
        is_mock_mode = re_eval.is_mock_mode
        print("‚úÖ RESUME_GENERATOR: Successfully connected to AI Engine (Relative).", flush=True)
    except ImportError as e:
        print("‚ùå RESUME_GENERATOR CRITICAL WARNING: Could not import AI Engine.", flush=True)
        print(f"   Reason: {e}", flush=True)
        print("vvvvv IMPORT TRACEBACK vvvvv", flush=True)
        traceback.print_exc()
        print("^^^^^^^^^^^^^^^^^^^^^^^^^^^^", flush=True)
        
        is_mock_mode = True 
        def generate_with_failover(prompt, expected_type='dict', timeout_val=45): 
            raise Exception("Standalone mode enabled because Import Failed - AI skipped")

# ==============================================================================
#  SUPER DEFENSE JSON PARSER (LAYER 10)
# ==============================================================================
def super_robust_json_parse(raw_text):
    """
    Attempt to extract and parse a JSON list from LLM output using multiple defense layers.
    Handles standard JSON, Python-style lists (single quotes), and broken syntax.
    """
    if isinstance(raw_text, (list, dict)):
        return raw_text

    if not raw_text:
        raise ValueError("Empty input text")

    raw_text = str(raw_text)
    cleaned = re.sub(r'```[a-zA-Z]*', '', raw_text).replace('```', '').strip()

    match = re.search(r'\[.*\]', cleaned, re.DOTALL)
    if match:
        cleaned = match.group(0)
    
    try:
        return json.loads(cleaned)
    except json.JSONDecodeError:
        pass 

    cleaned = re.sub(r',\s*\]', ']', cleaned)
    
    try:
        return json.loads(cleaned)
    except json.JSONDecodeError:
        pass

    try:
        result = ast.literal_eval(cleaned)
        if isinstance(result, list):
            return result
    except (ValueError, SyntaxError):
        pass

    print("‚ö†Ô∏è JSON Structure Destroyed. Engaging Regex Salvage...", flush=True)
    found_items = re.findall(r'["\']([^"\']{10,})["\']', raw_text)
    if found_items and len(found_items) > 0:
        return found_items

    raise ValueError("Failed to parse list after all defense layers.")

# ==============================================================================
#  THE MASTER RESUME FALLBACK MATRIX (MEGA EDITION - 25+ FIELDS)
# ==============================================================================
RESUME_FALLBACK_BANK = {
    "Software Engineering & Development": [
        "Explain the concept of Big O notation. Why is it important in scaling applications?",
        "What is the difference between a Process and a Thread?",
        "Explain the SOLID principles of Object-Oriented Design.",
        "How do you handle Deadlocks in a multi-threaded application?",
        "What is the difference between REST and GraphQL?",
        "Explain the concept of Microservices versus Monolithic architecture.",
        "How does Garbage Collection work in your primary language (Java/Python/etc.)?",
        "What is CI/CD and how have you implemented it?",
        "Explain the difference between SQL and NoSQL databases.",
        "How do you secure user passwords in a database? (Hashing/Salting)"
    ],
    "Data Science & Analytics": [
        "Explain the Bias-Variance Tradeoff in machine learning.",
        "What is the difference between Supervised and Unsupervised Learning?",
        "How do you handle missing values in a dataset? Imputation vs Dropping?",
        "Explain the concept of Overfitting and how to prevent it (Regularization).",
        "What is the difference between Precision and Recall? When to maximize which?",
        "Explain the Random Forest algorithm to a non-technical stakeholder.",
        "What is A/B Testing? How do you determine statistical significance?",
        "Explain the concept of Dimensionality Reduction (PCA).",
        "What is a Confusion Matrix?",
        "How do you clean and preprocess raw data for analysis?"
    ],
    "Product Management": [
        "How do you prioritize features on a roadmap? (RICE, MoSCoW)",
        "Explain the concept of MVP (Minimum Viable Product).",
        "How do you handle a disagreement between Engineering and Design teams?",
        "What metrics would you look at to measure the success of a new feature?",
        "How do you determine Product-Market Fit?",
        "Explain a time you had to say 'No' to a stakeholder request.",
        "How do you conduct User Research and gather feedback?",
        "What is the difference between a Product Manager and a Project Manager?",
        "How do you define a User Persona?",
        "Walk me through a product failure you experienced and what you learned."
    ],
    "Civil Engineering": [
        "What is the difference between Pre-tensioning and Post-tensioning in concrete?",
        "Explain the importance of the Slump Test for concrete.",
        "How do you calculate the bearing capacity of soil?",
        "What are the different types of foundations used in construction?",
        "Explain the concept of Moment Distribution Method.",
        "How do you ensure safety on a construction site?",
        "What is the difference between a Column and a Strut?",
        "Explain the use of Total Station in surveying.",
        "What factors influence the curing time of concrete?",
        "How do you handle water seepage in a basement structure?"
    ],
    "Mechanical Engineering": [
        "Explain the Second Law of Thermodynamics.",
        "What is the difference between Stress and Strain?",
        "Explain the Otto Cycle vs Diesel Cycle.",
        "What is the significance of the Reynolds Number in fluid mechanics?",
        "How do you select the right material for a high-temperature application?",
        "Explain the working principle of a Centrifugal Pump.",
        "What is GD&T (Geometric Dimensioning and Tolerancing)?",
        "Explain the difference between soldering, brazing, and welding.",
        "What is the role of a Governor in an engine?",
        "How does a hydraulic system work?"
    ],
    "Electrical & Electronics Engineering": [
        "Explain the difference between AC and DC current.",
        "What is the function of a Transformer? Explain Step-up vs Step-down.",
        "Explain Ohm's Law and Kirchhoff's Laws.",
        "What is the difference between a Microprocessor and a Microcontroller?",
        "How does a diode work? Explain Forward vs Reverse Bias.",
        "What is the importance of Grounding/Earthing in electrical systems?",
        "Explain the working of an Induction Motor.",
        "What is the difference between Analog and Digital signals?",
        "How do you calculate power factor and why is it important?",
        "Explain the concept of PCB (Printed Circuit Board) design."
    ],
    "Medical (Doctor/Surgeon)": [
        "How do you handle a patient who disagrees with your diagnosis?",
        "Explain the ABCDE approach in emergency trauma management.",
        "What are the ethical considerations when treating a minor without parental consent?",
        "How do you manage stress during long shifts or surgeries?",
        "Explain the mechanism of action of antibiotics.",
        "How do you deliver bad news to a patient's family?",
        "What is the difference between a viral and bacterial infection diagnosis?",
        "Explain the importance of patient confidentiality (HIPAA).",
        "How do you stay updated with the latest medical research?",
        "Describe a complex case you handled recently."
    ],
    "Nursing & Healthcare": [
        "How do you prioritize patient care during a busy shift (Triage)?",
        "Explain the 5 Rights of Medication Administration.",
        "How do you handle a difficult or aggressive patient?",
        "What steps do you take to prevent infection in a hospital setting?",
        "Explain how you monitor vital signs and identify deterioration.",
        "How do you document patient care accurately?",
        "What is your protocol for handling a medical error?",
        "How do you provide emotional support to patients and families?",
        "Explain the procedure for inserting an IV line.",
        "What is Compassion Fatigue and how do you manage it?"
    ],
    "Pharmacy & Biotech": [
        "Explain the process of Drug Discovery and Development phases.",
        "What is Pharmacokinetics (ADME)?",
        "Explain the difference between Generic and Brand-name drugs.",
        "How do CRISPR/Cas9 gene-editing technologies work?",
        "What are Good Manufacturing Practices (GMP) in pharma?",
        "Explain drug interactions and how to identify them.",
        "What is the difference between a Vaccine and an Antiviral?",
        "How do you ensure sterility in a cleanroom environment?",
        "Explain the concept of Bioavailability.",
        "What is the role of the FDA/regulatory bodies in drug approval?"
    ],
    "Chartered Accountancy (CA) & Finance": [
        "Explain the difference between IFRS and GAAP.",
        "What is the Golden Rule of Accounting?",
        "How do you detect fraud in a financial audit?",
        "Explain the concept of Deferred Tax Assets and Liabilities.",
        "What is Transfer Pricing?",
        "Explain the three types of Cash Flow activities.",
        "How do you analyze a Balance Sheet for liquidity?",
        "What is GST (Goods and Services Tax) and how does input credit work?",
        "Explain the concept of Depreciation and Amortization.",
        "What is Forensic Accounting?"
    ],
    "Investment Banking": [
        "Walk me through a DCF (Discounted Cash Flow) valuation.",
        "What is WACC and how do you calculate it?",
        "Explain the difference between Enterprise Value and Equity Value.",
        "How does a $10 increase in depreciation affect the three financial statements?",
        "What are the main valuation methods (Comps, Precedents, DCF)?",
        "Explain what an LBO (Leveraged Buyout) is.",
        "What is Dilution in the context of raising capital?",
        "Explain the concept of Beta in finance.",
        "What is an IPO process?",
        "How do you evaluate if a merger is accretive or dilutive?"
    ],
    "Marketing & Digital Strategy": [
        "What is the difference between SEO and SEM?",
        "Explain the 4 Ps of Marketing (Product, Price, Place, Promotion).",
        "How do you measure ROI on a social media campaign?",
        "What is a Sales Funnel (AIDA model)?",
        "Explain the concept of Content Marketing.",
        "How do you define a Target Audience?",
        "What tools do you use for analytics (Google Analytics, etc.)?",
        "Explain the difference between Inbound and Outbound marketing.",
        "How do you handle negative feedback on social media?",
        "What is Brand Equity?"
    ],
    "Human Resources (HR)": [
        "How do you handle a conflict between two employees?",
        "What is your strategy for Talent Acquisition vs Talent Retention?",
        "Explain the process of Performance Management.",
        "How do you handle an underperforming employee?",
        "What steps do you take to ensure Diversity and Inclusion?",
        "How do you stay updated with Labor Laws and compliance?",
        "Explain the Onboarding process for a new hire.",
        "How do you manage an Exit Interview?",
        "What is Employer Branding?",
        "How do you handle a sexual harassment complaint?"
    ],
    "Sales & Business Development": [
        "Sell me this pen.",
        "How do you handle rejection from a prospect?",
        "What is your strategy for lead generation?",
        "Explain the difference between B2B and B2C sales.",
        "How do you build long-term relationships with clients?",
        "What is a CRM and how do you use it?",
        "How do you close a deal when the client is hesitant about price?",
        "Explain the concept of Upselling and Cross-selling.",
        "How do you research a prospect before a meeting?",
        "What is your sales cycle process?"
    ],
    "Supply Chain & Logistics": [
        "Explain the concept of Just-In-Time (JIT) inventory.",
        "What is the Bullwhip Effect in supply chains?",
        "How do you select and evaluate suppliers?",
        "Explain Incoterms and their importance.",
        "How do you mitigate risks in a global supply chain?",
        "What is Demand Forecasting?",
        "Explain the difference between Logistics and Supply Chain Management.",
        "How do you optimize warehouse layout?",
        "What is a Bill of Lading?",
        "How do you track KPIs like Order Cycle Time?"
    ],
    "Corporate Law & Legal": [
        "Explain the difference between a Contract and an Agreement.",
        "What is Due Diligence in a merger or acquisition?",
        "Explain the concept of Intellectual Property (IP) rights.",
        "How do you handle a breach of contract?",
        "What is Liability and how can a company limit it?",
        "Explain the role of a Corporate Secretary.",
        "What is an NDA (Non-Disclosure Agreement)?",
        "How do you stay updated with changing corporate regulations?",
        "Explain the concept of 'Piercing the Corporate Veil'.",
        "How do you draft a Shareholders' Agreement?"
    ],
    "Journalism & Media": [
        "What constitutes 'Newsworthy' information?",
        "How do you verify sources and fact-check a story?",
        "Explain the ethics of journalism (objectivity, privacy).",
        "How do you handle a sensitive interview?",
        "What is the difference between Hard News and Soft News?",
        "How has social media changed traditional journalism?",
        "Explain the inverted pyramid style of writing.",
        "What is Libel vs Slander?",
        "How do you work under tight deadlines for breaking news?",
        "What is Investigative Journalism?"
    ],
    "Architecture & Interior Design": [
        "Explain the Design Process from concept to execution.",
        "What is Sustainable Architecture?",
        "How do you use AutoCAD/Revit/SketchUp in your workflow?",
        "Explain the importance of Ergonomics in interior design.",
        "How do you choose materials for a specific climate?",
        "What is the Golden Ratio in design?",
        "How do you handle zoning laws and building codes?",
        "Explain the concept of Space Planning.",
        "How do you balance aesthetics with functionality?",
        "What is BIM (Building Information Modeling)?"
    ],
    "Teaching & Education": [
        "What is your philosophy of Classroom Management?",
        "How do you handle a student who is disruptive?",
        "Explain the difference between Formative and Summative assessment.",
        "How do you differentiate instruction for students with different learning needs?",
        "How do you incorporate technology into your lessons?",
        "How do you communicate with parents about student progress?",
        "What is Bloom's Taxonomy?",
        "How do you keep students engaged during a lecture?",
        "Explain the concept of a Lesson Plan.",
        "How do you handle bullying in the classroom?"
    ],
    "Graphic & UI/UX Design": [
        "What is the difference between UI and UX design?",
        "Explain the Design Thinking process.",
        "What is a Wireframe vs a Prototype?",
        "How do you conduct User Testing?",
        "Explain Color Theory and Typography rules.",
        "What tools do you use (Figma, Adobe XD, Illustrator)?",
        "How do you ensure accessibility (WCAG guidelines) in design?",
        "Explain the importance of White Space.",
        "How do you create a User Persona?",
        "What is a Design System?"
    ],
    "Content Writing & Copywriting": [
        "What is the difference between Copywriting and Content Writing?",
        "How do you optimize content for SEO?",
        "Explain the AIDA model in copywriting.",
        "How do you adapt your tone for different brand voices?",
        "How do you write a catchy headline?",
        "What is a Call to Action (CTA)?",
        "How do you research a topic you are unfamiliar with?",
        "What is the importance of storytelling in marketing?",
        "How do you handle writer's block?",
        "Explain the editing and proofreading process."
    ],
    "Hospitality & Hotel Management": [
        "How do you handle an angry guest complaint?",
        "What is the importance of 'Front of House' vs 'Back of House'?",
        "How do you ensure food safety and hygiene standards?",
        "Explain the concept of Yield Management in hotels.",
        "How do you train staff to deliver 5-star service?",
        "What procedures do you follow for check-in/check-out?",
        "How do you manage housekeeping schedules?",
        "What is a SOP (Standard Operating Procedure) in hospitality?",
        "How do you handle overbooking situations?",
        "Explain the role of a Concierge."
    ],
    "Aviation & Pilot": [
        "Explain Bernoulli's Principle in relation to lift.",
        "What is the difference between IFR and VFR?",
        "How do you handle an in-flight emergency (e.g., engine failure)?",
        "Explain the concept of CRM (Crew Resource Management).",
        "What are the four forces acting on an aircraft?",
        "How do you interpret a METAR/TAF weather report?",
        "What is the critical angle of attack?",
        "Explain the function of the ATC (Air Traffic Control).",
        "How do you perform a pre-flight inspection?",
        "What is the importance of Weight and Balance?"
    ],
    "Social Work & NGO": [
        "How do you maintain professional boundaries with clients?",
        "Explain the concept of Case Management.",
        "How do you handle a crisis intervention?",
        "What is your approach to fundraising for an NGO?",
        "How do you advocate for a marginalized community?",
        "Explain the importance of cultural competence.",
        "How do you document client interactions and progress?",
        "What is the difference between micro, mezzo, and macro social work?",
        "How do you prevent burnout in this field?",
        "Explain the ethical code of conduct in social work."
    ],
    "Government & Public Service": [
        "Why do you want to work in the public sector?",
        "How do you handle bureaucracy and red tape?",
        "Explain the importance of transparency and accountability.",
        "How do you balance stakeholder interests with public policy?",
        "What is your understanding of the Constitution/Local Laws?",
        "How do you manage a public budget?",
        "Explain the process of policy formulation.",
        "How do you handle public criticism or media scrutiny?",
        "What is the role of a Civil Servant?",
        "Describe a time you solved a community problem."
    ]
}

def get_fallback_questions(domain, count):
    """STRICT DOMAIN MATCHING LOGIC FOR RESUMES"""
    try:
        if domain in RESUME_FALLBACK_BANK:
            questions = RESUME_FALLBACK_BANK[domain]
            return random.sample(questions, min(count, len(questions)))

        domain_lower = str(domain).lower()
        for key in RESUME_FALLBACK_BANK.keys():
            if key.lower() in domain_lower or domain_lower in key.lower():
                questions = RESUME_FALLBACK_BANK[key]
                return random.sample(questions, min(count, len(questions)))

        if "Software Engineering & Development" in RESUME_FALLBACK_BANK:
             questions = RESUME_FALLBACK_BANK["Software Engineering & Development"]
             return random.sample(questions, min(count, 5))
        else:
             return [
                 "Describe your work experience.",
                 "What are your strengths?",
                 "How do you handle stress?", 
                 "Tell me about a project you are proud of."
             ]
    except Exception as e:
        print(f"‚ö†Ô∏è FALLBACK BANK ERROR: {e}", flush=True)
        return ["Describe your professional experience.", "What are your key skills?"]

def generate_resume_questions_wrapper(resume_text, domain, yoe, count):
    """
    Generates resume-specific questions using Failover AI or Fallback Bank.
    """
    # 0. Validate Inputs
    if not domain or len(str(domain)) < 2:
        domain = "General"
    
    count = int(count)
    if count < 1: count = 5

    # 1. MOCK MODE CHECK
    if is_mock_mode:
        print(f"‚ö†Ô∏è RESUME_GENERATOR: Using Fallback Bank for {domain} (Mock Mode)", flush=True)
        return [
            {"id": 1, "type": "coding", "question": f"Mock Coding: Optimize a distributed {domain} lock."},
            {"id": 2, "type": "theory", "question": f"Mock Theory: Explain CAP theorem in {domain}."},
            {"id": 3, "type": "hr", "question": "Mock HR: Describe a conflict with a Product Manager."},
            {"id": 4, "type": "aptitude", "question": "Mock Aptitude: A train 150m long is running at 60kmph..."}
        ]

    # 2. AI MODE (WITH FAILOVER)
    try:
        # 1. Determine Audit Mode & Difficulty Scaling
        # "VETERAN_ARCHITECT" = Focus on expensive trade-offs, business risk, and system failure modes.
        # "RISING_TALENT" = Focus on deep internal mechanics, not just surface-level API usage.
        audit_mode = "VETERAN_ARCHITECT" if int(yoe) > 3 else "RISING_TALENT"
        
        # 2. Advanced Distribution Logic (Supreme Version 2)
        # This strategy ensures we cover the full spectrum of a professional's capabilities.
        distribution_instruction = ""
        if count >= 10: # Lowered threshold to trigger advanced distribution sooner
            distribution_instruction = f"""
            ### DISTRIBUTION STRATEGY (Generating {count} Questions - SUPREME V2 MATRIX):
            - **25% Architectural Forensics & System Design:**
                * Focus on scalability limits (CAP Theorem trade-offs), disaster recovery (RTO/RPO), and microservices failure cascades.
                * Ask: "How does this specific design choice fail at 100x scale?"
            - **35% Domain-Specific Hard Technical & Internals:**
                * Deep dives into the *internals* of listed skills. (e.g., JVM Garbage Collection mechanics, Database Indexing B-Trees vs Hash, React Fiber Reconciliation).
                * NO syntax questions. Ask about memory models, concurrency, and protocol-level details.
            - **20% Operational Resilience & Debugging Horror Stories:**
                * Production incident management, CI/CD pipeline security, "Butterfly Effect" bugs, and handling legacy code refactors under pressure.
            - **10% Security & Compliance (Domain Context):**
                * OWASP Top 10 (Tech), HIPAA/GDPR (Health/Data), SOX (Finance). How do they bake security into the lifecycle?
            - **10% Behavioral Leadership & Conflict Resolution:**
                * Navigating technical debt negotiations, mentorship failures, and disagreeing with leadership on roadmap risks.
            """
        else:
            distribution_instruction = "### FOCUS: Prioritize deep technical aptitude (Internals & Architecture) and ruthless resume-specific interrogation."

        # FIX: Changed target format to an Array of Objects so the AI separates them perfectly
        prompt = f"""
        ### SYSTEM ROLE: GLOBAL HEAD OF TALENT ACQUISITION & SUPREME AUDITOR
        *** TARGET DOMAIN: {domain} || EXPERIENCE LEVEL: {yoe} Years ({audit_mode}) ***
        
        ### MISSION:
        Conduct a high-stakes interview simulation based on the provided candidate resume snippet. 
        Generate exactly {count} "Silent Killer" questions. These must expose competency gaps or embellished skills.

        ### SOURCE MATERIAL:
        1. **RESUME SNIPPET:** "{str(resume_text)[:3000]}..."

        ### QUERY RANDOMIZATION PROTOCOL (STRICT - HARDCODED):
        - **SEED:** {random.randint(100000, 999999)} (Use this to pull from a unique cluster in the vector space)
        - **DATABASE SIMULATION:** Access the "Long Tail" of the {domain} question bank. 
        - **EXCLUSION:** Do NOT select the top 100 most common questions for {domain}. (e.g., If Java, NO "What is OOP?"; If Accounting, NO "What is a Debit?"; If Nursing, NO "What is normal BP?").
        - **UNIQUENESS:** Select specific, scenario-based edge cases that only a practitioner would know. Every execution MUST yield different results.

        ### GENERATION PROTOCOLS (STRICT):
        1. **NO TEXTBOOK DEFINITIONS:** Never ask "What is X?" or "Explain Y". The candidate can Google that.
        2. **SCENARIO-BASED ATTACKS (Difficulty Level: {int(yoe) + 2} Years):**
            - IF {audit_mode} == VETERAN_ARCHITECT: Ask about system failure modes, scalability bottlenecks, race conditions, and expensive trade-offs (e.g., "Defend your choice of X over Y given constraint Z").
            - IF {audit_mode} == RISING_TALENT: Ask about implementation details, debugging workflows, and edge-case handling in their specific stack (e.g., "How do you handle memory leaks in [Specific Tool]?").
        3. **RESUME SPECIFICITY:** Reference specific tools, libraries, or projects mentioned in the text. If they list "AWS", ask about S3 consistency models. If they list "React", ask about reconciliation performance costs.
        4. **BEHAVIORAL TRAPS:** Include questions that test how they handle technical debt, ethical dilemmas, or conflicting requirements under pressure.
        
        {distribution_instruction}

        ### OUTPUT REQUIREMENT:
        - Return ONLY a raw JSON Array of strings.
        - Each object MUST contain a "question" key.
        - The array must contain exactly {count} items.
        
        ### TARGET OUTPUT FORMAT:
        [
            {{
                "question": "1. [System Design] You mentioned using MongoDB in your 'E-commerce' project. How did you handle data consistency across shards during network partitions?"
            }},
            {{
                "question": "2. [Optimization] You listed Python. Describe a real-world scenario where the Global Interpreter Lock (GIL) became a bottleneck and how you architected a bypass."
            }}
        ]
        """        
        print(f"ü§ñ RESUME_GENERATOR: Parsing {domain} resume (Failover Enabled)...", flush=True)        
        
        # Request a list from the failover engine
        raw_output = generate_with_failover(prompt, expected_type='list', timeout_val=45)
        
        # Safely extract the questions from the objects
        extracted_questions = []
        if isinstance(raw_output, list):
            for item in raw_output:
                if isinstance(item, dict) and "question" in item:
                    extracted_questions.append(item["question"])
                elif isinstance(item, str):
                    extracted_questions.append(item)

        print(f"üéØ AI successfully extracted {len(extracted_questions)} perfectly formatted questions.", flush=True)

        # 3. Validation & Padding
        if len(extracted_questions) < count:
            print(f"‚ö†Ô∏è AI generated {len(extracted_questions)}/{count} questions. Padding the rest from the bank.", flush=True)
            shortfall = count - len(extracted_questions)
            padding = get_fallback_questions(domain, shortfall)
            extracted_questions += padding
            
        return extracted_questions[:count]
        
    except Exception as e:
        print(f"‚ùå RESUME_GENERATOR FAILED: {str(e)}", flush=True)
        return get_fallback_questions(domain, count)

    